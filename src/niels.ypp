%{
#include <cinttypes>
#include <cstdint>
#include <climits>
#include <cstdio>
#include <cfloat>
#include <iostream>
#include <typeinfo>
#include <cstring>
using namespace std;
#include "ast.h"
extern "C" int yylex();
extern "C" int yyparse();
extern "C" FILE *yyin;

nir::Node* program;         // Root of the AST
bool fewerNoops = true;  // Whether or not Noop nodes should be removed

extern "C" void yyerror(const char *s);
%}
%define parse.error verbose
%union {
    nir::Node*   node;
    int32_t i32;
    int64_t i64;
    float   r32;
    double  r64;
    bool    boolean;
    char*   str;
}

%right <operator> ALIAS ASSIGN

%right <operator> AS

%left <operator> ADD SUB
%left <operator> MUL DIV MOD POW

%left <operator> LTHAN GTHAN
%left <operator> EQUAL
%left <operator> LTHAN_EQUAL
%left <operator> GTHAN_EQUAL

%left <operator> OR XOR AND

%right <operator> INVERT NEGATE QUERY

%token IMPORT
%token NL
%token LPAREN RPAREN 
%token LBRACK RBRACK
%token LBRACE RBRACE
%token COMMA COLON SEMICOLON

%token <i32> INT32
%token <i64> INT64
%token <r32> REAL32
%token <r64> REAL64
%token <str> STRING
%token <boolean> BOOL

%token <str> IDENT
%token <str> RETURN FUNCTION WHILE WHEN IS OTHERWISE RECORD

%token <operator> AT
%token <str> COMMENT


%type <node> input module block stmts stmt expr scalar val shape range arg args param params function while return
%type <node> when is otherwise cases
%type <node> import
%type <node> record attr attrs

%%

input: %empty { }
    | stmts { 
        $$ = new nir::Collection(new nir::Ident(strdup("Root")), $1);
        program = $$;
    }
;

module: IDENT LBRACE RBRACE { $$ = new nir::Module(new nir::Ident($1), new nir::Noop()); }
    | IDENT LBRACE expr RBRACE { $$ = new nir::Module(new nir::Ident($1), $3); }
    | IDENT LBRACE stmt RBRACE { $$ = new nir::Module(new nir::Ident($1), $3); }
    | IDENT LBRACE stmts RBRACE { $$ = new nir::Module(new nir::Ident($1), $3); }
;

import: IMPORT IDENT {
        $$ = new nir::Import(new nir::Ident($2));
    }
;

block: LBRACE RBRACE {
        $$ = new nir::Block(new nir::Anon(), new nir::Noop());
    }
    | LBRACE expr RBRACE {
        $$ = new nir::Block(new nir::Anon(), $2);
    }
    | LBRACE stmt RBRACE {
        $$ = new nir::Block(new nir::Anon(), $2);
    }
    | LBRACE stmts RBRACE {
        $$ = new nir::Block(new nir::Anon(), $2);
    }
;

return: RETURN expr NL {
        $$ = new nir::Return($2);
    }
;

function: FUNCTION IDENT LPAREN params RPAREN block {
        $$ = new nir::Function(
            new nir::FunctionDecl(new nir::Ident($2), $4),
            $6
        );
    }
;

while: WHILE LPAREN expr RPAREN block {
        $$ = new nir::While($3, $5);
    }
;

is: IS LPAREN scalar RPAREN block {
        $$ = new nir::Is($3, $5);
    }
;
otherwise: OTHERWISE block {
        $$ = new nir::Otherwise(new nir::Bool(true), $2);
    }
;
cases:  is {
        $$ = new nir::Cases($1);
    }
    | cases is {
        $1->append(new nir::Cases($2));
        $$ = $1;
    }
;
when: WHEN LPAREN expr RPAREN cases {
        $5->append(new nir::Cases(
            new nir::Otherwise(
                new nir::Bool(true),
                new nir::Block(new nir::Anon(), new nir::Noop())
            )
        ));
        $$ = new nir::When($3, $5);
    }
    | WHEN LPAREN expr RPAREN cases otherwise {
        $5->append(new nir::Cases($6));
        $$ = new nir::When($3, $5);
    }
    | WHEN LPAREN expr RPAREN block {
        $$ = new nir::WhenBool($3, new nir::Cases(
            new nir::Is(new nir::Bool(true), $5),
            new nir::Cases(new nir::Otherwise(
                new nir::Bool(true),
                new nir::Block(new nir::Anon(), new nir::Noop()))
            )));
    }
    | WHEN LPAREN expr RPAREN block otherwise {
        $$ = new nir::WhenBool($3, new nir::Cases(
            new nir::Is(new nir::Bool(true), $5),
            new nir::Cases($6)
        ));

    }
;

stmts: stmt {
        $$ = new nir::StmtList($1);
        $$->left(NULL);
        $$->right($1);
    }
    | stmts stmt {
        if (fewerNoops && ((typeid(*$2) == typeid(nir::Noop)))) {
            $$ = $1;
        } else {
            $$ = new nir::StmtList($1, $2);
        }
    }
;

stmt: NL { $$ = new nir::Noop(); }
    | COMMENT { $$ = new nir::Comment($1); }
    | expr NL { $$ = $1; }
    | IDENT ASSIGN expr { $$ = new nir::Assign(new nir::Ident($1), $3); }
    | IDENT ALIAS expr {  $$ = new nir::Alias(new nir::Ident($1), $3); }
    | QUERY expr  { $$ = new nir::Query($2); }
    | module { $$ = $1; }
    | function { $$ = $1; }
    | return { $$ = $1; }
    | record { $$ = $1; }
    | when { $$ = $1; }
    | while { $$ = $1; }
    | block { $$ = $1; }
    | import { $$ = $1; }
;

scalar: INT32  { $$ = new nir::Int32($1); }
    | INT64  { $$ = new nir::Int64($1); }
    | REAL32 { $$ = new nir::Real32($1); }
    | REAL64 { $$ = new nir::Real64($1); }
    | BOOL { $$ = new nir::Bool($1); }
;
val: scalar { $$ = $1; }
    | STRING { $$ = new nir::Str($1); }
;
shape: expr { $$ = new nir::Shape($1); }
    | shape COMMA expr {
        $1->right(new nir::Shape($3));
        $$ = $1;
    }
;
range: LBRACK expr SEMICOLON expr RBRACK { $$ = new nir::Range(false, false, $2, $4 ); }
    | LBRACK expr SEMICOLON expr LBRACK { $$ = new nir::Range(false, true, $2, $4 ); }
    | RBRACK expr SEMICOLON expr RBRACK { $$ = new nir::Range(true, false, $2, $4 ); }
    | RBRACK expr SEMICOLON expr LBRACK { $$ = new nir::Range(true, true, $2, $4 ); }
    | expr SEMICOLON expr { $$ = new nir::Range(false, false, $1, $3 ); }
;

attr: IDENT ASSIGN scalar NL {
        $$ = new nir::Attr(new nir::Ident($1), $3);
    }
;
attrs: %empty { $$ = new nir::Empty(); }
    | attr { $$ = new nir::AttrList($1); }
    | attrs attr {
        $1->right(new nir::AttrList($2));
        $$ = $1;
    }
;
record: RECORD IDENT LBRACE NL attrs RBRACE {
        $$ = new nir::RecDef(new nir::Ident($2), $5);
    }
;

param: IDENT {
        $$ = new nir::Param(
            new nir::Ident($1),
            new nir::Undefined()
        );
    }
;
params: %empty { $$ = new nir::Empty(); }
    | param { $$ = new nir::ParamList($1); }
    | params COMMA param {
        $1->right(new nir::ParamList($3));
        $$ = $1;
    }
;

arg: expr {
        $$ = new nir::Arg(
            $1,
            new nir::Undefined()
        );
    }
;
args: %empty { $$ = new nir::Empty(); }
    | arg { $$ = new nir::ArgList($1); }
    | args COMMA arg {
        $1->right(new nir::ArgList($3));
        $$ = $1;
    }
;

expr: val { $$ = $1; }
    | range { $$ = $1; }
    | IDENT   { $$ = new nir::Ident($1); }
    | LPAREN expr RPAREN { $$ = $2; }
    | IDENT LPAREN args RPAREN {
        $$ = new nir::Call(
            new nir::Ident($1),
            $3
        );
    }
    | expr ADD expr  { $$ = new nir::Add($1, $3); }
    | expr SUB expr  { $$ = new nir::Sub($1, $3); }
    | expr MUL expr  { $$ = new nir::Mul($1, $3); }
    | expr DIV expr  { $$ = new nir::Div($1, $3); }
    | expr POW expr  { $$ = new nir::Pow($1, $3); }
    | expr LTHAN expr  { $$ = new nir::LThan($1, $3); }
    | NEGATE expr { $$ = new nir::Neg($2); }
    | INVERT expr { $$ = new nir::Inv($2); }
    | expr AS LPAREN shape RPAREN { $$ = new nir::As($1, $4); }
;

%%
void yyerror(const char *s) {
    cout << "Doh! " << s << endl;
    exit(-1);
}

int main(int, char**) {
    FILE *myfile = fopen("input.nls", "r");
    if (!myfile) {
        cout << "I cannot open input.nls!" << endl;
        return -1;
    }
    
    yyin = myfile;  // Switch from STDIN to 'input.nls'
    do {
        yyparse();
    } while (!feof(yyin));
    cout << nir::dot(program) << endl;
}

