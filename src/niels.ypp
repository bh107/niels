%{
#include <cinttypes>
#include <cstdint>
#include <climits>
#include <cstdio>
#include <cfloat>
#include <cmath>
#include <iostream>
#include <stack>
using namespace std;
#include "ast.h"
extern "C" int yylex();
extern "C" int yyparse();
extern "C" FILE *yyin;

void yyerror(const char *s);
%}
%define parse.error verbose
%union {
    nir::Node*   node;
    int32_t i32;
    int64_t i64;
    float   r32;
    double  r64;
    bool    boolean;
    char*   str;
}

%right <operator> ALIAS ASSIGN

%right <operator> AS

%left <operator> ADD SUB
%left <operator> MUL DIV MOD POW

%left <operator> LTHAN GTHAN
%left <operator> EQUAL
%left <operator> LTHAN_EQUAL
%left <operator> GTHAN_EQUAL

%left <operator> OR XOR AND

%right <operator> INVERT NEGATE QUERY

%token NL
%token LPAREN RPAREN 
%token LBRACK RBRACK
%token LBRACE RBRACE
%token COMMA COLON SEMICOLON

%token <i32> INT32
%token <i64> INT64
%token <r32> REAL32
%token <r64> REAL64
%token <str> STRING
%token <boolean> BOOL

%token <str> IDENT
%token <str> RETURN DEFINE WHILE WHEN IS OTHERWISE

%token <str> COMMENT

%type <node> input stmts stmt block expr scalar shape range args def while
%type <node> when is is_chain otherwise

%%

input: %empty { }
    | stmts { 
        $$ = new nir::Program();
        $$->right($1);
        cout << dot($$) << endl;
    }
;

block: LBRACE RBRACE { $$ = new nir::Block(new nir::Anon(), new nir::Noop()); }
    | LBRACE expr RBRACE { $$ = new nir::Block(new nir::Anon(), $2); }
    | LBRACE stmt RBRACE { $$ = new nir::Block(new nir::Anon(), $2); }
    | LBRACE stmts RBRACE { $$ = new nir::Block(new nir::Anon(), $2); }
    | IDENT LBRACE RBRACE { $$ = new nir::Block(new nir::Ident($1), new nir::Noop()); }
    | IDENT LBRACE expr RBRACE { $$ = new nir::Block(new nir::Ident($1), $3); }
    | IDENT LBRACE stmt RBRACE { $$ = new nir::Block(new nir::Ident($1), $3); }
    | IDENT LBRACE stmts RBRACE { $$ = new nir::Block(new nir::Ident($1), $3); }
;

def: DEFINE IDENT LPAREN RPAREN block {
        $$ = new nir::FuncDef(new nir::Ident($2), $5);
    }
;

while: WHILE LPAREN expr RPAREN block {
        $$ = new nir::While($3, $5);
    }
;

is: IS LPAREN scalar RPAREN block {
        $$ = new nir::Is($3, $5);
    }
;
is_chain: %empty { $$ = new nir::CaseList(); }
    | is { $$ = new nir::CaseList($1); }
    | is_chain is {
        $$ = $1; $1->right(new nir::CaseList($2));
    }
;

otherwise: %empty {
        $$ = new nir::CaseList(new nir::Otherwise(new nir::Bool(false), new nir::Noop()));
    }
    | OTHERWISE block {
        $$ = new nir::CaseList(new nir::Otherwise(new nir::Bool(true), $2));
    }
;

when: WHEN LPAREN expr RPAREN is_chain otherwise {
        $$ = new nir::When($3, $5);
        nir::Node* next = $5;
        while(next->right()) {
            next = next->right();
        }
        next->right($6);
    }
    | WHEN LPAREN expr RPAREN block otherwise {
        nir::Node* _case = new nir::CaseList(new nir::Is(new nir::Bool(true), $5));
        $$ = new nir::When($3, _case);
        nir::Node* next = _case;
        while(next->right()) {
            next = next->right();
        }
        next->right($6);
    }
;

stmts: stmt { $$ = new nir::StmtList($1); }
    | stmts stmt {
        nir::Node* next = $1;
        while(next->right()) {
            next = next->right();
        }
        next->right(new nir::StmtList($2));
    }
;

stmt: NL { $$ = new nir::Noop(); }
    | COMMENT { $$ = new nir::Comment($1); }
    | expr NL { $$ = $1; }
    | def { $$ = $1; }
    | when { $$ = $1; }
    | while { $$ = $1; }
    | block { $$ = $1; }
;


scalar: INT32  { $$ = new nir::Int32($1); }
    | INT64  { $$ = new nir::Int64($1); }
    | REAL32 { $$ = new nir::Real32($1); }
    | REAL64 { $$ = new nir::Real64($1); }
    | BOOL { $$ = new nir::Bool($1); }
    | STRING { $$ = new nir::Str($1); }
;

shape: expr { $$ = new nir::Shape($1); }
    | shape COMMA expr {
        $1->right(new nir::Shape($3));
        $$ = $1;
    }
;

args: expr { $$ = new nir::Arg($1); }
    | args COMMA expr {
        $1->right(new nir::Arg($3));
        $$ = $1;
    }
;

range: LBRACK expr SEMICOLON expr RBRACK { $$ = new nir::Range(false, false, $2, $4 ); }
    | LBRACK expr SEMICOLON expr LBRACK { $$ = new nir::Range(false, true, $2, $4 ); }
    | RBRACK expr SEMICOLON expr RBRACK { $$ = new nir::Range(true, false, $2, $4 ); }
    | RBRACK expr SEMICOLON expr LBRACK { $$ = new nir::Range(true, true, $2, $4 ); }
    | expr SEMICOLON expr { $$ = new nir::Range(false, false, $1, $3 ); }
;

expr: scalar { $$ = $1; }
    | range
    | IDENT   { $$ = new nir::Ident($1); }
    | LPAREN expr RPAREN { $$ = $2; }
    | IDENT ASSIGN expr { $$ = new nir::Assign(new nir::Ident($1), $3); }
    | IDENT ALIAS expr {  $$ = new nir::Alias(new nir::Ident($1), $3); }
    | IDENT LPAREN args RPAREN {
        $$ = new nir::FuncCall(
            new nir::Ident($1),
            $3
        );
    }
    | expr ADD expr  { $$ = new nir::Add($1, $3); }
    | expr SUB expr  { $$ = new nir::Sub($1, $3); }
    | expr MUL expr  { $$ = new nir::Mul($1, $3); }
    | expr DIV expr  { $$ = new nir::Div($1, $3); }
    | expr POW expr  { $$ = new nir::Pow($1, $3); }
    | expr LTHAN expr  { $$ = new nir::LThan($1, $3); }
    | NEGATE expr { $$ = new nir::Neg($2); }
    | INVERT expr { $$ = new nir::Inv($2); }
    | QUERY expr  { $$ = new nir::Query($2); }
    | expr AS LPAREN shape RPAREN { $$ = new nir::As($1, $4); }
;

%%
int main(int, char**) {
    FILE *myfile = fopen("input.nls", "r");
    if (!myfile) {
        cout << "I cannot open input.nls!" << endl;
        return -1;
    }
    
    yyin = myfile;  // Switch from STDIN to 'input.nls'
    do {
        yyparse();
    } while (!feof(yyin));
}

void yyerror(const char *s) {
    cout << "Doh! " << s << endl;
    exit(-1);
}

